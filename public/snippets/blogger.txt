const port = 3000;

const http = require("http"); //to host server, handle requests
const fs = require("fs");
const url = require("url");
const https = require("https");
const querystring = require("querystring");
const crypto = require("crypto");
const server = http.createServer();

server.on('request', requestHandler);

const {client_id, client_secret, scope} = require('./auth/credentials.json');
let all_sessions = [];

function requestHandler(req, res){
    console.log(`New request from ${req.headers.host} for ${req.url}:\n`);
    if(req.url == '/'){
        const homepage = fs.createReadStream('./html/index.html');
        res.writeHead(200, {'Content-Type':'text/html'});
        homepage.pipe(res); //write data from homepage to res object given to users browser, we tell it how to interpret the file
    }
     
    else if(req.url == '/favicon.ico'){ //handles secondary/tertiary reqs for favicon usually made, or simply handles a direct route to favicon
        const favicon = fs.createReadStream('./images/favicon.ico');
        res.writeHead(200, {'Content-Type':'image/x-image'});
        favicon.pipe(res); //write data from favicon to res object given to users browser, we tell it how to interpret the file
    }

    else if(req.url.startsWith('/submitted')){ //data will be embedded in the url generated by the form, starting with the route submitted
        console.log(`Submission of data from ${req.headers.host}`);
        const input = new URL(req.url, `https://localhost:${port}`).searchParams; //property of url that lets us access decoded query strings via get 
        const artist = (input.get('artist')); //get the artist and song input from user
        const song = (input.get('song'));
        console.log("Request for lyrics of: " + artist + ": " + song);

        if(artist == '' || artist == null || song == '' || song == null){ //end response if bad submission
            console.log('404 Error');
            res.writeHead(404, {'Content-Type':'text/html'});
            res.write("<h1>404! No submission!</h1>");
            res.end();
        } 
        
        else {
            //if we recieved good input, send the first api request!
            const lyrics_req = https.request(`https://api.lyrics.ovh/v1/${artist}/${song}`); //fill in parameters of request
        
            lyrics_req.on("response", (lyrics_response) => {
                //https request gets a response, we want to use it
                toMessage(lyrics_response, parse_lyrics, res, artist, song);
            });

            lyrics_req.on("error", () => {
                console.log("Lyrics request error!");
            })

            lyrics_req.end(() => {}); //send request
        }
    }// end - /submitted 

    else if(req.url.startsWith('/retrieve_code')){ /*after the server parses 
        the lyrics returned from api, call get_Auth_code which redirects user to grant access and provide a auth code */
        const {code, state} = url.parse(req.url, true).query; //use query info from url
        console.log(`Authorization code: ${code}\nState: ${state}\n`);
        let session = all_sessions.find(session => session.state === state);

        if(code === undefined || state === undefined || session === undefined){
            notFound(res);
            res.end();
            return;
        }

        const {artist, song, lyrics} = session;
        console.log(`After the redirect we still have access to...`);
        console.log(`Artist: ${artist}, Song: ${song}, Lyrics: ${lyrics?.substring(0,20)}`);

        retrieveAccessToken(code, res, artist, song, lyrics); //pass code to retrieve acc token
    } 

    else {
        notFound(res);
    }
}

server.listen(port, () => {
    console.log(`Listening on port ${port}...`);
});

function notFound(res){
    console.log('404 Error');
    res.writeHead(404, {'Content-Type':'text/html'});
    res.write('404! Nothing found.');
}

function toMessage(stream, callback, ...args){ //kinda so we can pass extra args thru a middleman
    let body = ""; 
    stream.on("data", (chunk) => { //stream recieves data, when it does add it to body, accumulate
        body += chunk;
    });
    stream.on("end", () => {
        callback(body, ...args);
    }); //when we're done pass it off to the callback for intended use with any other arguments we need
}

//the result we're passed is a jsonString so we need to parse it into something readable
function parse_lyrics(jsonString, res, artist, song){
    

    lyrics = JSON.parse(jsonString)?.lyrics;
    console.log(artist + ": " + song);
    console.log(`${lyrics?.substring(0, 50)}...\n`);

    //bc of 3 legged oauths redirects, we need to save user_input
    const state = crypto.randomBytes(20).toString("hex");
    all_sessions.push({artist, song, lyrics, state});
    
    get_auth_code(state, res); //to ensure we execute after parsing lyrics.ovh results
    
}

function get_auth_code(state, res){
    const endpoint = 'https://accounts.google.com/o/oauth2/v2/auth';

    let myParams = {client_id, scope, state, 'response_type' : 'code', 'redirect_uri':`http://localhost:${port}/retrieve_code`};
    const uri = new URLSearchParams(myParams).toString();

    //here we redirect the user to in order to grant permissions to server, we then go to /retrieve_code with the auth code embedded in the url
    console.log(`Getting auth code from: ${endpoint}?${uri}`);
    res.writeHead(302, {Location:`${endpoint}?${uri}`});
    res.end();
}

function retrieveAccessToken(code, res, ...args){
    //sundays work + write to app

    const token_endpoint = "https://oauth2.googleapis.com/token";

    let form = {   
        client_id, 
        client_secret, 
        code, 
        grant_type: "authorization_code",
        redirect_uri: "http://localhost:3000/retrieve_code",
    };

    const post_data = new URLSearchParams(form).toString();

    let options = {
        method: 'POST',
        headers: {
            "Content-Type": "application/x-www-form-urlencoded"
        }
    }

    const token_req = https.request(token_endpoint, options, (token_stream) => {
        toMessage(token_stream, recieve_access_token, res, ...args);
    });

    token_req.on("error", () => {
        notFound(res);
        res.end();
    });

    token_req.end(post_data);
    
}

function recieve_access_token(data, res, ...args){
    const jsonData = JSON.parse(data);
    const access_token = jsonData.access_token;

    //we need the user's blog id in order to write,
        //to get it we need to supply access token
    req_blog_id(access_token, res, ...args);

    console.log(`Access Token: ${access_token}\n`);
} 

function req_blog_id(access_token, res, ...args){

    if(access_token == null || access_token == ''){
        notFound(res);
        res.end();
    } 

    else {
        const token_endpoint = "https://www.googleapis.com/blogger/v3/users/self/blogs";

        let options = {
            method: 'GET',
            headers: {
                "Authorization": `Bearer ${access_token}`
            }
        }

        const blogId_req = https.request(token_endpoint, options, (blogInfo) => {
            toMessage(blogInfo, req_write_to_blogger, access_token, res, ...args);
        });

        blogId_req.on("error", () => {
            console.log("Error requesting blog info!");
            res.end();
        });
        
        blogId_req.end();
    }

    
}

function req_write_to_blogger(body, access_token, res, artist, song, lyrics){

    if(access_token == null || access_token == ''){
        notFound(res);
        res.end;
    }

    const blogInfo = JSON.parse(body);

    if(blogInfo?.items === undefined || blogInfo?.items === ""){
        //no account exists
        notFound(res);
        res.end();
        return;
    }

    const blogId = blogInfo?.items[0]?.id;
    console.log(`Blog Id: ${blogId}`)

    const token_endpoint = `https://www.googleapis.com/blogger/v3/blogs/${blogId}/posts/`;

    const options = {
        method: "POST",
        headers: {
            "Authorization" : `Bearer ${access_token}`,
            "kind" : "blogger#post",
            "blog" : {
                "id" : blogId
            },
            "resource" : {
                "title": `${artist}: ${song}`,
                "content": `${lyrics}`
            }
        }
    }

    const write_post_req = https.request(token_endpoint, options, (write_res) => {
        toMessage(write_res, tellUser, res, artist, song, lyrics);
    });
    
    write_post_req.on("error", () => {
        console.log("Error writing post!");
    });

    write_post_req.end();

};

function tellUser(body, res, artist, song, lyrics){
    const response = JSON.parse(body);
    console.log(`Response after writing to blog! ${body}\n`);
    res.writeHead(200, {'Content-Type':'text/html'});
        res.write(`<h1>Server authenticated by user! </h1>
        <h6> See your new blog post <a href="${response?.url}"> here </a></h6>
        <p>We tried writing the lyrics from ${artist.toUpperCase()}: ${song.toUpperCase()}, to your blog! But the api only lets us write a blank document! </p>
        <p>Lyrics: ${lyrics}</p>`);
    res.end();
}